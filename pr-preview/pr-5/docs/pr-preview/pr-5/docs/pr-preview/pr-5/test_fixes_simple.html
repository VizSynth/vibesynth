<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Fix Tests</title>
</head>
<body>
    <h1>Simple Fix Tests (No WebGL Required)</h1>
    <div id="test-results"></div>
    <button onclick="runSimpleTests()">Run Tests</button>
    
    <script>
        // Mock minimal required objects for testing without WebGL
        window.nodes = [];
        window.nodeCount = 0;
        let testResults = [];
        
        function log(message, isError = false) {
            console.log(message);
            const div = document.getElementById('test-results');
            const p = document.createElement('p');
            p.textContent = message;
            p.style.color = isError ? 'red' : 'green';
            div.appendChild(p);
        }
        
        // Mock cursorComponents (from actual code)
        const cursorComponents = {
            x: { value: 0.5, name: 'X Position (0-1)' },
            y: { value: 0.3, name: 'Y Position (0-1)' },
            velocity: { value: 0.1, name: 'Movement Velocity (0-1)' },
            click: { value: 0, name: 'Click State (0-1)' }
        };
        
        // Mock removeSelfReferences function (copy from our implementation)
        function removeSelfReferences() {
            let fixedCount = 0;
            
            nodes.forEach(node => {
                // Check regular inputs
                for (let i = 0; i < node.inputs.length; i++) {
                    if (node.inputs[i] === node) {
                        console.log(`Removing self-reference from ${node.name} input ${i}`);
                        node.inputs[i] = null;
                        fixedCount++;
                    }
                }
                
                // Check control inputs
                if (node.controlInputs) {
                    for (let i = 0; i < node.controlInputs.length; i++) {
                        if (node.controlInputs[i] === node) {
                            console.log(`Removing self-reference from ${node.name} control input ${i}`);
                            node.controlInputs[i] = null;
                            fixedCount++;
                        }
                    }
                }
            });
            
            return fixedCount;
        }
        
        // Mock createControlInputNode function
        function createControlInputNode(type) {
            const node = {
                id: ++nodeCount,
                type: type,
                name: `${type} ${nodeCount}`,
                inputs: [],
                params: { component: 'x', min: 0.0, max: 1.0 },
                controlInputs: null
            };
            nodes.push(node);
            return node;
        }
        
        // Mock createNode function
        function createNode(type, x, y) {
            const node = {
                id: ++nodeCount,
                type: type,
                name: `${type} ${nodeCount}`,
                x: x,
                y: y,
                inputs: [null, null],
                controlInputs: null
            };
            nodes.push(node);
            return node;
        }
        
        // Mock deleteNode function
        function deleteNode(node) {
            const index = nodes.indexOf(node);
            if (index > -1) {
                nodes.splice(index, 1);
            }
        }
        
        // Mock getValue function (copy cursor input logic from our fix)
        function getValue(node) {
            if (node.type === 'CursorInput') {
                const component = node.params.component;
                let rawCursorValue = 0;
                if (component === 'x') {
                    rawCursorValue = cursorComponents.x.value;
                } else if (component === 'y') {
                    rawCursorValue = cursorComponents.y.value;
                } else if (component === 'velocity') {
                    rawCursorValue = cursorComponents.velocity.value;
                } else if (component === 'click') {
                    rawCursorValue = cursorComponents.click.value;
                }
                // Map to configured min/max range
                const cursorMin = node.params.min || 0;
                const cursorMax = node.params.max || 1;
                return cursorMin + (rawCursorValue * (cursorMax - cursorMin));
            }
            return 0;
        }
        
        function testCursorInputComponents() {
            log('üß™ Testing Cursor Input Components...');
            
            try {
                // Test that all components exist
                const expectedComponents = ['x', 'y', 'velocity', 'click'];
                for (const component of expectedComponents) {
                    if (!cursorComponents[component]) {
                        log(`‚ùå Component '${component}' missing`, true);
                        return false;
                    }
                    log(`‚úÖ Component '${component}' exists`);
                }
                
                // Test creating cursor input node
                const cursorNode = createControlInputNode('CursorInput');
                log('‚úÖ Created CursorInput node');
                
                // Test each component
                for (const component of expectedComponents) {
                    cursorNode.params.component = component;
                    const value = getValue(cursorNode);
                    
                    if (typeof value !== 'number') {
                        log(`‚ùå Component '${component}' should return number, got ${typeof value}`, true);
                        return false;
                    }
                    
                    if (value < 0 || value > 1) {
                        log(`‚ùå Component '${component}' value ${value} outside 0-1 range`, true);
                        return false;
                    }
                    
                    log(`‚úÖ Component '${component}' returns: ${value}`);
                }
                
                // Test range mapping
                cursorNode.params.component = 'x';
                cursorNode.params.min = 0.2;
                cursorNode.params.max = 0.8;
                
                const mappedValue = getValue(cursorNode);
                const expectedValue = 0.2 + (0.5 * (0.8 - 0.2)); // 0.5
                
                if (Math.abs(mappedValue - expectedValue) > 0.001) {
                    log(`‚ùå Range mapping failed: expected ${expectedValue}, got ${mappedValue}`, true);
                    return false;
                }
                
                log(`‚úÖ Range mapping works: ${mappedValue}`);
                deleteNode(cursorNode);
                
                log('‚úÖ Cursor input test PASSED!');
                return true;
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                return false;
            }
        }
        
        function testCircularDependencyFix() {
            log('üß™ Testing Circular Dependency Fix...');
            
            try {
                // Create a node and give it a self-reference
                const testNode = createNode('Oscillator', 100, 100);
                log('‚úÖ Created test node');
                
                // Create self-reference
                testNode.inputs[0] = testNode;
                log('‚úÖ Created artificial self-reference');
                
                // Test removal
                const fixedCount = removeSelfReferences();
                
                if (fixedCount !== 1) {
                    log(`‚ùå Expected to fix 1 self-reference, fixed ${fixedCount}`, true);
                    return false;
                }
                
                if (testNode.inputs[0] !== null) {
                    log(`‚ùå Self-reference not removed`, true);
                    return false;
                }
                
                log(`‚úÖ Fixed ${fixedCount} self-reference(s)`);
                
                // Test that normal connections are preserved
                const testNode2 = createNode('Noise', 200, 100);
                testNode.inputs[0] = testNode2;
                
                const fixedCount2 = removeSelfReferences();
                if (fixedCount2 !== 0) {
                    log(`‚ùå Valid connection was incorrectly removed`, true);
                    return false;
                }
                
                if (testNode.inputs[0] !== testNode2) {
                    log(`‚ùå Valid connection was lost`, true);
                    return false;
                }
                
                log('‚úÖ Valid connections preserved');
                
                deleteNode(testNode);
                deleteNode(testNode2);
                
                log('‚úÖ Circular dependency test PASSED!');
                return true;
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                return false;
            }
        }
        
        function runSimpleTests() {
            document.getElementById('test-results').innerHTML = '';
            log('üöÄ Running Simple Fix Tests...');
            
            const cursorTest = testCursorInputComponents();
            const circularTest = testCircularDependencyFix();
            
            if (cursorTest && circularTest) {
                log('üéâ ALL TESTS PASSED! Fixes are working correctly.');
            } else {
                log('‚ùå Some tests failed.', true);
            }
        }
        
        // Auto-run tests
        setTimeout(runSimpleTests, 1000);
    </script>
</body>
</html>